# 闭包和高阶函数

## 闭包

### 变量的作用域

通常用 `var` 关键字声明的变量是一个全局的变量 如果在作用域内声明 比如函数内部 那么他就是这个函数作用域内的变量

### 变量的生存周期

1. 全局变量的生命周期是永久的 除非我们手动的去销毁他
2. 对于在函数内部用var声明的变量来说 当退出函数时等于失去了价值 会随着函数调用的结束而销毁
3. 当函数内部有一个函数 这个函数内部使用了父函数内部的变量 那么这个变量就不会像第二点说的 会随着函数调用的结束而销毁 这样就形成了闭包
4. 常见事件点击点击的例子 (01.html)
5. 过程与数据的结合是形容面向对象中的'对象' 用面向对象的思想实现的功能用闭包可以实现 反之亦然

### 内存泄漏

首先 闭包并不是造成内存泄漏的原因 根据实际使用来讲 局部的变量是我们刻意定义然后在闭包中使用的 因为我们可能会用到这些变量 所以这和存在局部还是全局作用域对内存的影响是一样的 

## 高阶函数

### 满足一下条件

1. 函数可以作为参数传递 (回调函数)
2. 函数可以作为返回值输出

### 面向切面编程

面向切面编程主要是把一些跟核心业务模块无关的功能抽离出来 在通过'动态织入'的方式惨入到核心业务模块 这样做的好好处是可以保持业务逻辑模块的纯净和高内聚性 其次是可以方便的复用这些功能模块

### currying (函数柯里化)

柯里化又称部分求值 一个柯里化函数会接收一些参数 并不会立即求值 而是继续返回另外一个函数 接收的参数会在函数闭包中被保存起来 待函数被真正求值的时候 之前传入的参数会一次性用于求值

### uncurrying (反柯里化)

在js里 我们不需要关心对象是否有某个方法 同理一个对象也未必只可以使用他自身拥有的 使用uncurrying的方式可以让对象借用一个原本不属于他的方法
